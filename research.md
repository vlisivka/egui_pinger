



# Дослідження: Захист VPN від аналізу трафіку через пінги

## Тема дослідження
Методи захисту VPN-тунелів від деанонімізації та аналізу трафіку (Traffic Analysis), що базуються на періодичних ICMP-запитах (пінгах).

## Мета
З'ясувати ризики тривалого пінгування одного хоста через VPN та знайти методи маскування цієї активності для захисту приватності користувача.

## Аналіз загрози
Навіть при сильному шифруванні (AES-256, ChaCha20), метадані трафіку залишаються видимими для спостерігача (провайдера, власника мережі):
1.  **Таймінг (Timing Attacks)**: Якщо програма відправляє пакет кожної секунди точно, спостерігач бачить сплеск трафіку в тунелі з частотою 1 Гц. Це створює "відбиток" (fingerprint).
2.  **Кореляція (Correlation Attacks)**: Зловмисник може порівняти таймінги пакетів на вході у VPN та на виході (на цільовому хості), щоб підтвердити, що конкретний користувач спілкується з конкретним сервером.
3.  **Розмір (Size analysis)**: ICMP-пакети мають стандартний розмір (наприклад, 84 байти з заголовками). Навіть у зашифрованому вигляді вони створюють кадри однакового розміру.

## Опис варіантів захисту

### 1. Випадкова затримка (Jitter)
Це найпростіший та найефективніший метод на рівні клієнта.
-   **Механізм**: Замість фіксованого інтервалу (наприклад, 1.00с) використовувати випадковий (наприклад, 1.00с ± 300мс).
-   **Ефект**: Руйнує математичну періодичність, що робить автоматичне виявлення патернів значно складнішим.
-   **Реалізація**: Вже інтегровано в `logic/pinger.rs` для деяких режимів.

### 2. Варіативність розміру пакета (Packet Padding)
Додавання випадкової кількості даних до "тіла" ICMP-пакета.
-   **Механізм**: Відправляти не стандартні 32/64 байти, а випадкову кількість від 16 до 1024 байт.
-   **Ефект**: Ускладнює фільтрацію за розміром пакета. Спостерігачеві важче відрізнити пінг від короткого запиту до API або DNS.

### 3. Тунелювання через обфусцировані протоколи
Використання додаткового шару маскування.
-   **Механізм**: Використання Cloak, ShadowSocks або V2Ray (VMess), які маскують трафік под звичайний HTTPS (TLS) або випадковий потік байтів.
-   **Ефект**: Пакет виглядає як частина звичайного веб-серфінгу.

### 4. Фоновий шум (Dummy Traffic)
Надсилання фіктивного трафіку паралельно з пінг-запитами.
-   **Механізм**: Програма або система періодично завантажує випадкові дані.
-   **Ефект**: Реальні пінги "губляться" в іншому трафіку.

## Рекомендації для проєкту
1.  **Поглиблений Jitter**: Впровадити обов'язковий джиттер (мінімум 10-15%) для всіх режимів, окрім "Дуже швидко", де швидкість є критичною.
2.  **Налаштування Padding**: Додати в конфігурацію хоста можливість вказати розмір пакета або увімкнути режим "Випадкового розміру" (наприклад, від 32 до 128 байт).
3.  **Порада користувачеві**: При роботі через VPN в недружніх мережах використовувати протоколи з обфускацією (наприклад, AmneziaWG або OpenVPN з Scramble).

## Вплив на проєкт
-   **model/status.rs**: Додати поле `packet_size` та `use_random_padding` до `HostInfo`.
-   **logic/pinger.rs**: Модифікувати створення ICMP-пакета для підтримки кастомного розміру.
-   **logic/pinger.rs**: Додати джиттер до всіх режимів.


# Дослідження: Структура Linux-архіву для розгортання в `~/.local`

## Тема дослідження
Створення оптимальної структури архіву для релізу програми `egui_pinger` на Linux, що дозволяє користувачеві встановити програму в домашню директорію (`~/.local`) без прав суперкористувача, з повною інтеграцією в системне меню та підтримкою іконок.

## Мета
Забезпечити "seamless" (безшовне) встановлення через розпакування одного архіву, що автоматично додасть програму в меню запуску та асоціює її з відповідною іконкою.

## Опис варіантів

### 1. Дзеркальна структура FHS (Рекомендовано)
Архів мітримує директорії `bin/` та `share/`, які повторюють ієрархію стандартної файлової системи Linux.
- **Механізм**: Користувач розпаковує архів безпосередньо в корінь своєї локальної директорії: `tar -xf egui_pinger.tar.gz -C ~/.local`.
- **Структура всередині архіву**:
    - `bin/egui_pinger` (виконуваний файл)
    - `share/applications/egui_pinger.desktop` (метадані для меню додатків)
    - `share/icons/hicolor/scalable/apps/egui_pinger.svg` (векторна іконка програми)
- **Переваги**: Повна відповідність стандартам Freedesktop. Не потребує складних скриптів інсталяції. Більшість сучасних дистрибутивів автоматично додають `~/.local/bin` до `$PATH`. Іконки та меню оновлюються автоматично системними сервісами.
- **Недоліки**: Користувачу потрібно вручну виконати команду розпакування (хоча це стандартна практика для Linux).

### 2. AppImage
Розповсюдження у вигляді одного самодостатнього виконуваного файлу.
- **Механізм**: Користувач завантажує файл `egui_pinger.AppImage`, надає права на виконання (`chmod +x`) і запускає.
- **Переваги**: Максимальна мобільність ("один файл — одна програма"). Працює на більшості дистрибутивів без встановлення.
- **Недоліки**: Потребує зовнішніх утиліт для інтеграції в системне меню (наприклад, AppImageLauncher). Складніше оновлювати. Може мати проблеми з FUSE на䧉 деяких сучасних системах (наприклад, Ubuntu 22.04+ без `libfuse2`).

### 3. Скриптований інсталятор (Bash Wrapper)
Архів, що містить бінарні файли та скрипт `install.sh`.
- **Механізм**: Користувач запускає `./install.sh`, який копіює файли в потрібні місця та налаштовує оточення.
- **Переваги**: Можливість автоматичної перевірки залежностей або додавання шляхів до `.bashrc` / `.zshrc`.
- **Недоліки**: Користувачі часто з підозрою ставляться до запуску скриптів від імені користувача. Важче підтримувати коректність роботи на різних оболонках (bash/zsh/fish).

## Рекомендації
Впровадити **Варіант 1 (Дзеркальна структура FHS)** як основний метод розповсюдження Linux-версії.
Для реалізації необхідно:
1.  **Desktop File**: Створити шаблон `egui_pinger.desktop` з `Exec=egui_pinger` та `Icon=egui_pinger`.
2.  **Icon**: Створити іконку в форматі SVG (масштабованість найкраще підходить для різних DE).
3.  **Build Automation**: Модифікувати `build-releases.sh` для створення тимчасової структури каталогів перед архівуванням.

## Вплив на проєкт
- **build-releases.sh**: Значне оновлення логіки пакування (замість просто бінарника — дерево папок).
- **assets/linux/**: Нова директорія для зберігання `.desktop` файлу та статичних ресурсів (іконок).
- **README.md**: Додати коротку інструкцію для користувачів щодо встановлення в `~/.local`.


# Дослідження: Вбудовування іконок у виконувані файли Windows (.exe)

## Тема дослідження
Забезпечення відображення іконки програми `egui_pinger` у Windows Explorer та на панелі завдань без використання зовнішніх файлів.

## Мета
Автоматизувати процес вбудовування ресурсів (іконки) у бінарний файл під час крос-компіляції з Linux за допомогою `cargo-xwin`.

## Опис варіантів

### 1. Використання `winres` (Рекомендовано)
Стандартний для Rust спосіб додавання ресурсів Windows через `build.rs`.
- **Механізм**:
    1.  Конвертація SVG іконки у формат `.ico` (мульти-роздільна здатність).
    2.  Додавання `winres` у `build-dependencies`.
    3.  Створення `build.rs`, що налаштовує іконку для Windows.
- **Переваги**: Працює автоматично під час `cargo build`. Підтримується `cargo-xwin`, оскільки він надає доступ до `rc.exe` (Resource Compiler) з Windows SDK.
- **Недоліки**: Потребує наявності ImageMagick або іншого інструменту для створення `.ico` файлу на етапі розробки.

### 2. Ручна компіляція `.rc` файлу
Створення файлу ресурсів вручну та його компіляція за допомогою зовнішніх інструментів.
- **Переваги**: Не потребує додаткових Rust-залежностей.
- **Недоліки**: Складніше підтримувати та автоматизувати крос-платформно.

## Рекомендації
Використовувати **Варіант 1 (winres)**:
1.  **Конвертація**: Використовувати ImageMagick: `convert icon.svg -define icon:auto-resize=16,32,48,64,256 icon.ico`.
2.  **Залежності**: Додати `winres` у `Cargo.toml`.
3.  **Build Script**: Додати `build.rs` з умовною компіляцією лише для вікон.

## Вплив на проєкт
- **assets/**: Створено `assets/linux/egui_pinger.ico`.
- **Cargo.toml**: Додано `winres` у `build-dependencies`.
- **build.rs**: Новий файл для керування ресурсами.
