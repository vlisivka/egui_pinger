# Дослідження: Тестування GUI для egui_pinger

## Мета
Визначити найбільш ефективні підходи та інструменти для тестування графічного інтерфейсу (GUI), побудованого на базі бібліотеки `egui` у Rust.

## Опис варіантів

### 1. Відокремлення логіки від UI (Логічне тестування)
Це фундаментальний підхід, де бізнес-логіка (розрахунок jitter, обробка відповідей пінгів, агрегація даних) виноситься в окремі модулі або структури, які не залежать від `egui`.
- **Переваги**: Швидкість, надійність, не потребує спеціальних інструментів для GUI.
- **Недоліки**: Не перевіряє безпосередньо взаємодію користувача з інтерфейсом (наприклад, чи натискається кнопка, чи очищуються поля введення).

### 2. Використання `egui_kittest` (Інтерактивне тестування)
Це сучасний рекомендований підхід для `egui`. Бібліотека побудована на базі `AccessKit` і дозволяє створювати віртуальне середовище ("Harness") для додатку.
- **Можливості**:
  - Емуляція кліків, введення тексту, фокусування.
  - Пошук елементів за мітками (labels) або ідентифікаторами.
  - Перевірка стану UI без рендерингу графіки.
- **Переваги**: Висока швидкість (не потребує GPU/вікна), хороша інтеграція з екосистемою `egui`.

### 3. Тестування знімками екрана (Snapshot/Screenshot Testing)
Використання бібліотек на кшталт `egui_kittest` (з фічею `snapshot`) або `egui-screenshot-testing`. Програма рендерить поточний стан додатку в зображення і порівнює його з еталонним ("golden image").
- **Переваги**: Виявляє візуальні регресії (зсуви пікселів, неправильні кольори, проблеми зі шрифтами).
- **Недоліки**: Чутливість до змін платформи/драйверів, великий об'єм артефактів (зображень) у репозиторії, складність оновлення.

## Рекомендації
Для `egui_pinger` я рекомендую комбінований підхід:
1. **Пріоритет (Етап 1)**: Використовувати **`egui_kittest`** для автоматизації перевірки функціоналу UI (додавання хостів, перемикання режимів). Це забезпечить якісну перевірку "користувацьких сценаріїв" без накладних витрат на графіку.
2. **Основа (Постійно)**: Максимальне покриття юніт-тестами структури `HostStatus` та логіки розрахунку метрик у `src/main.rs` (або в нових модулях).
3. **Візуальний контроль (Етап 2)**: Додати snapshot-тести лише для критичних елементів графіки (History Sparklines), щоб гарантувати коректність відображення графіків.

## Вплив на проєкт
- **Файли**: Буде додано каталог `tests/` з інтеграційними тестами.
- **Cargo.toml**: Додавання `egui_kittest` у `[dev-dependencies]`.
- **src/main.rs**: Потребує невеликого рефакторингу для того, щоб структуру додатка (`EguiPinger`) можна було легко ініціалізувати в тестовому гайді без запуску реального вікна `eframe`.

# Дослідження: Параметри діагностики IP-телефонії (SIP/VoIP)

## Мета
Визначити ключові параметри мережі, що впливають на якість SIP-зв'язку, та інструменти для їх вимірювання (NAT, Firewall, VPN, затримки).

## Опис варіантів та інструментів

### 1. Базові метрики якості (QoS)
*   **Latency (RTT)**: Затримка пакетів між вузлами.
    *   *Інструмент*: `ping`, `mtr`.
    *   *SIP норма*: < 150 мс для комфортної розмови. Якщо > 300 мс, розмова стає переривчастою.
*   **Jitter (Тремтіння затримки)**: Нерівномірність часу приходу пакетів.
    *   *Інструмент*: `mtr` (статистика Jnt), спеціалізовані формули (T3/T21/T99).
    *   *SIP норма*: < 30 мс. Високий jitter викликає розриви аудіо ("роботизований голос").
*   **Packet Loss**: Втрата пакетів у мережі.
    *   *Інструмент*: `ping` (тривалий тест), `mtr`.
    *   *SIP норма*: < 1%. Навіть при втраті 3% розмова стає майже неможливою.

### 2. Діагностика маршруту та обмежень
*   **Traceroute / MTR**: Виявлення проблемного проміжного вузла. Допомагає зрозуміти, чи затримка виникає всередині локальної мережі, у провайдера, чи на магістральних стиках.
*   **Rate Limiting (Шейпінг)**:
    *   *Метод*: Порівняння результатів ICMP-пінгів та UDP-пінгів на SIP-порт (5060). Якщо ICMP проходить без втрат, а UDP блокується — це ознака фільтрації.
    *   *Інструмент*: `hping3 --udp -p 5060` або `nmap`.

### 3. NAT та Firewall (Найбільш складні проблеми SIP)
*   **NAT Traversal**:
    *   *Проблема*: "One-way audio" (звук лише в один бік), коли вхідний медіа-потік (RTP) блокується NAT.
    *   *Інструмент*: `stuntman` (STUN-клієнт). Визначає тип NAT: Cone (добре) або Symmetric (проблемно для SIP).
*   **SIP ALG (Application Layer Gateway)**:
    *   *Проблема*: Функція роутера, яка часто пошкоджує SIP-заголовки, змінюючи IP-адреси там, де не потрібно.
    *   *Діагностика*: Перевірка цілісності пакетів SIP (співпадіння IP в заголовку `Contact` та IP відправника) за допомогою `sngrep` або `tcpdump`.

### 4. VPN та MTU
*   **MTU / Fragmentation**:
    *   *Проблема*: VPN додає накладні витрати (overhead), через що великі SIP-пакети можуть фрагментуватися або блокуватися.
    *   *Інструмент*: `ping -s 1472 -M do` (Path MTU Discovery) для пошуку оптимального розміру пакету.

## Рекомендації для реалізації в egui_pinger
1.  **Автоматична діагностика**: При виявленні втрат пакетів (Loss > 2%) додаток має автоматично запускати `mtr` у фоновому режимі та зберігати звіт.
2.  **UDP-пінги на SIP-порт**: Крім ICMP, реалізувати UDP-тести на порт 5060, оскільки вони краще відображають реальний стан проходження SIP-сигналізації.
3.  **Перевірка DNS SRV**: SIP часто покладається на DNS SRV-записи. Потрібно додати перевірку доступності та часу відповіді через `nslookup` або `dig`.
4.  **Модуль звітів**: Створити вкладку "Debug/Report", де будуть зібрані виводи всіх утиліт для передачі техпідтримці провайдера.

## Вплив на проєкт
*   **src/pinger/**: Потребує розширення для підтримки UDP-пінгів.
*   **src/diag/**: Новий модуль для обробки виводу системних утиліт (`mtr`, `nslookup`).
*   **UI**: Додавання розширених графіків та кнопок "Запустити повну діагностику".

# Дослідження: Реалізація Drag & Drop для перестановки рядків у egui

## Мета
Визначити оптимальний спосіб реалізації зміни порядку хостів у списку за допомогою перетягування мишею (Drag & Drop) в інтерфейсі `egui`.

## Опис варіантів

### 1. Нативний підхід (egui::DragAndDrop)
Бібліотека `egui` має вбудовану підтримку перетягування через API `dnd_drag_source` та `dnd_drop_zone`.
- **Як це працює**: 
  - Кожен рядок (або спеціальна іконка-ручка) обгортається у `ui.dnd_drag_source`.
  - Весь контейнер списку обгортається у `ui.dnd_drop_zone`.
  - Під час перетягування ми отримуємо інформацію про те, який елемент та над яким місцем знаходиться.
- **Переваги**: Не потребує додаткових залежностей. Повний контроль над візуалізацією.
- **Недоліки**: Потребує самостійної реалізації логіки розрахунку індексу вставки (визначення, між якими елементами зараз знаходиться курсор).

### 2. Використання бібліотеки `egui_dnd`
Цей крейт розроблений спеціально для спрощення сортування списків у `egui`.
- **Як це працює**: 
  - Використовується компонент `dnd(ui, "unique_id").show(items, |ui, item, handle, state| { ... })`.
  - Бібліотека автоматично обробляє анімації зміщення елементів та оновлення порядку в масиві.
- **Переваги**: Дуже швидка інтеграція. Плавні анімації "з коробки". Коректна обробка різних розмірів елементів.
- **Недоліки**: Додаткова залежність у проєкті.

### 3. Ручна реалізація через `Sense::drag()`
Взаємодія на рівні подій миші: `response.drag_delta()`.
- **Переваги**: Максимальна кастомізація.
- **Недоліки**: Велика кількість "ручного" коду для обробки станів, що може призвести до помилок у логіці UI.

## Рекомендації
Для `egui_pinger` я рекомендую **Варіант 1 (Нативний підхід)**, якщо ми хочемо зберегти проєкт легким, або **Варіант 2 (egui_dnd)**, якщо пріоритетом є якісна анімація та швидкість розробки.

Оскільки ми використовуємо `egui 0.33`, нативного функціоналу достатньо для реалізації простого переміщення:
1. Додати іконку `☰` зліва від назви хоста.
2. Використати `ui.dnd_drag_source` для іконки.
3. Використати `ui.dnd_drop_zone` для всього `ScrollArea`.
4. Оновити `AppState.hosts` на основі отриманих подій Drop.

## Вплив на проєкт
- **src/main.rs**: Рефакторинг циклу відображення хостів.
- **src/model/app_state.rs**: Додавання методу для перестановки елементів у векторі.
